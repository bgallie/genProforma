// Copyright 2020 Billy G. Allie.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

// genProforma is a utility to create the proforma rotors and permutators used
// by tnt2 (an implementation of the "Infinite Key Ecryption" system from the
// Dr. Dobbs Journal artical).  It can generate the proforma machine (a set of
// rotors and permutators) using Go's cyrpt/rand package or by using a key and
// the Rand method of github.com/bgallie/tntengine package.  Proforma machines
// generated by a secret key will be identical to proforma machines generated
// with the same secret key.

import (
	cRand "crypto/rand"
	"encoding/json"
	"flag"
	"fmt"
	"math/big"
	"os"
	"strings"

	"github.com/bgallie/tntengine"
	"github.com/bgallie/utilities"
	"golang.org/x/crypto/ssh/terminal"
)

var (
	tntMachine      tntengine.TntEngine
	rotorSizes      []int
	rotorSizesIndex int
	cycleSizes      []int
	rRead           func([]byte) (n int, err error)
	rInt            func(int64) int64
	outputFileName  string
	random          *tntengine.Rand
	rotor1          = new(tntengine.Rotor)
	rotor2          = new(tntengine.Rotor)
	rotor3          = new(tntengine.Rotor)
	rotor4          = new(tntengine.Rotor)
	rotor5          = new(tntengine.Rotor)
	rotor6          = new(tntengine.Rotor)
	permutator1     = new(tntengine.Permutator)
	permutator2     = new(tntengine.Permutator)
	proFormaMachine = []tntengine.Crypter{rotor1, rotor2, permutator1, rotor3, rotor4, permutator2, rotor5, rotor6}
	checkFatal      = utilities.CheckFatal
	turnOffLogging  = utilities.TurnOffLogging
	turnOnLogging   = utilities.TurnOnLogging
	truelyRandom    = false
	rCnt            = 0
	pCnt            = 0
	outputFile      = os.Stdout
)

func init() {
	flag.StringVar(&outputFileName, "outputFile", "", "output file name")
	flag.StringVar(&outputFileName, "of", "", "output file name (shorthand)")
	flag.Parse()

	// Obtain the passphrase used to encrypt the file from either:
	// 1. User input from the terminal
	// 2. The 'tnt2Secret' environment variable
	// 3. Arguments from the entered command line
	var secret string
	var exists bool
	if flag.NArg() == 0 {
		secret, exists = os.LookupEnv("tnt2Secret")
		if !exists {
			// fmt.Fprintf(os.Stderr, "IsTerminal: %s\n", terminal.IsTerminal(int(os.Stdin.Fd())))
			if terminal.IsTerminal(int(os.Stdin.Fd())) {
				fmt.Fprintf(os.Stderr, "Enter the passphrase: ")
				byteSecret, err := terminal.ReadPassword(int(os.Stdin.Fd()))
				checkFatal(err)
				fmt.Fprintln(os.Stderr, "")
				secret = string(byteSecret)
			}
		}
	} else {
		secret = strings.Join(flag.Args(), " ")
	}

	truelyRandom = (len(secret) == 0)

	// Define rRead and rInt based on weither we are generating a cryptographically
	// strong set of rotors and permatators
	if truelyRandom {
		fmt.Fprintln(os.Stderr, "Generating truly random rotors and permutators.")
		// Define rRead and rInt to use the crypto/rand based functions.
		rRead = cRand.Read
		rInt = cInt
	} else {
		tntMachine.Init([]byte(secret), "")
		tntMachine.SetEngineType("E")
		// Now the the engine type is set, build the cipher machine.
		tntMachine.BuildCipherMachine()
		// Get the random functions
		random = tntengine.NewRand(&tntMachine)
		rRead = random.Read
		rInt = random.Int63n
	}

	// rotoSizes is an array of possible rotor sizes.  It consists of prime
	// numbers less than 1792 to allow for a 256 bit splce at the end of the
	// rotor and still be less then or equal to 2048 bits (32 bytes).  The rotor
	// sizes selected from this list will maximizes the number of unique states
	// the rotors can take.
	rotorSizes = []int{
		1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733,
		1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789}

	// Define a random order of rotor sizes based on the key.
	rotorSizesPerm := perm(len(rotorSizes))
	for i, val := range rotorSizesPerm {
		rotorSizesPerm[i] = rotorSizes[val]
	}

	rotorSizes = rotorSizesPerm

	// Define a random order of cycle sizes based on the key.
	cycleSizes = perm(len(tntengine.CycleSizes))
}

func cInt(n int64) int64 {
	max := big.NewInt(n)
	j, err := cRand.Int(cRand.Reader, max)
	checkFatal(err)
	return j.Int64()
}

func perm(n int) []int {
	res := make([]int, n, n)

	for i := range res {
		res[i] = i
	}

	for i := (n - 1); i > 0; i-- {
		j := rInt(int64(i))
		res[i], res[j] = res[j], res[i]
	}

	return res
}

func randP() []byte {
	res := make([]byte, 256, 256)

	for i := range res {
		res[i] = byte(i)
	}

	for i := (256 - 1); i > 0; i-- {
		j := int(rInt(int64(i)))
		res[i], res[j] = res[j], res[i]
	}

	return res
}

func updateRotor(r *tntengine.Rotor) {
	r.Size = rotorSizes[rCnt]
	r.Start = int(rInt(int64(r.Size)))
	r.Current = r.Start
	r.Step = int(rInt(int64(r.Size)))
	// blkCnt is the total number of bytes needed to hold rotorSize bits + a slice of 256 bits
	blkCnt := ((r.Size + tntengine.CypherBlockSize + 7) / 8)
	r.Rotor = make([]byte, blkCnt, blkCnt)
	_, err := rRead(r.Rotor)
	checkFatal(err)

	//Slice the first 256 bits of the rotor to the end of the rotor
	var j = r.Size
	for i := 0; i < 256; i++ {
		if tntengine.GetBit(r.Rotor, uint(i)) {
			tntengine.SetBit(r.Rotor, uint(j))
		} else {
			tntengine.ClrBit(r.Rotor, uint(j))
		}
		j++
	}

	rCnt++
}

func updatePermutator(p *tntengine.Permutator) {
	p.Randp = randP()
	p.Cycles = make([]tntengine.Cycle, tntengine.NumberPermutationCycles)

	for i := range p.Cycles {
		p.Cycles[i].Length = tntengine.CycleSizes[cycleSizes[pCnt]][i]
		p.Cycles[i].Current = 0
		// Adjust the start to reflect the lenght of the previous cycles
		if i == 0 { // no previous cycle so start at 0
			p.Cycles[i].Start = 0
		} else {
			p.Cycles[i].Start = p.Cycles[i-1].Start + p.Cycles[i-1].Length
		}
	}

	p.CurrentState = 0
	p.MaximalStates = p.Cycles[0].Length

	for i := 1; i < len(p.Cycles); i++ {
		p.MaximalStates *= p.Cycles[i].Length
	}

	pCnt++
}

func main() {
	var err error
	// Update the rotors and permutators in a very non-linear fashion.
	for _, machine := range proFormaMachine {
		switch v := machine.(type) {
		default:
			fmt.Fprintf(os.Stderr, "Unknown machine: %v\n", v)
		case *tntengine.Rotor:
			updateRotor(machine.(*tntengine.Rotor))
		case *tntengine.Permutator:
			updatePermutator(machine.(*tntengine.Permutator))
		case *tntengine.Counter:
			machine.(*tntengine.Counter).SetIndex(big.NewInt(0))
		}
	}

	if len(outputFileName) != 0 {
		outputFile, err = os.Create(outputFileName)
		checkFatal(err)
	}

	defer outputFile.Close()
	jEncoder := json.NewEncoder(outputFile)
	jEncoder.SetEscapeHTML(false)

	for _, machine := range proFormaMachine {
		switch v := machine.(type) {
		default:
			fmt.Fprintf(os.Stderr, "Unknown machine: %v\n", v)
		case *tntengine.Rotor:
			err = jEncoder.Encode(machine.(*tntengine.Rotor))
			checkFatal(err)
		case *tntengine.Permutator:
			err = jEncoder.Encode(machine.(*tntengine.Permutator))
			checkFatal(err)
		}
	}
}
